package com.example.myapplication

import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*

object WavUtils {
    
    fun File.writeWav(audioData: List<Short>, sampleRate: Int = 16000) {
        FileOutputStream(this).use { fos ->
            val dataSize = audioData.size * 2
            val fileSize = dataSize + 36
            
            // WAV header with proper byte order (little-endian)
            fos.write("RIFF".toByteArray())
            fos.write(fileSize.toLittleEndianByteArray())
            fos.write("WAVE".toByteArray())
            fos.write("fmt ".toByteArray())
            fos.write(16.toLittleEndianByteArray()) // PCM header size
            fos.write(1.toLittleEndianShortArray()) // PCM format
            fos.write(1.toLittleEndianShortArray()) // Mono
            fos.write(sampleRate.toLittleEndianByteArray()) // Sample rate
            fos.write((sampleRate * 2).toLittleEndianByteArray()) // Byte rate
            fos.write(2.toLittleEndianShortArray()) // Block align
            fos.write(16.toLittleEndianShortArray()) // Bits per sample
            fos.write("data".toByteArray())
            fos.write(dataSize.toLittleEndianByteArray())
            
            // Audio data in little-endian format
            audioData.forEach { sample -> 
                fos.write(sample.toLittleEndianByteArray()) 
            }
        }
    }
    
    fun File.writeTranscript(audioData: List<Short>, timestamp: String, sampleRate: Int = 16000, realTranscription: String = ""): String {
        val duration = audioData.size / sampleRate.toFloat()
        
        // Use real transcription if available, otherwise provide fallback
        val transcription = if (realTranscription.isNotBlank()) {
            realTranscription
        } else {
            "[No speech detected or recognition failed]"
        }
        
        val content = """
            === VOICE RECORDING TRANSCRIPT ===
            Timestamp: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}
            Audio File: voice_${timestamp}.wav
            Duration: ${"%.2f".format(duration)}s
            Sample Rate: ${sampleRate}Hz
            Samples: ${audioData.size}
            STT Engine: Android SpeechRecognizer (On-device)
            ================================
            
            TRANSCRIPTION:
            $transcription
            
            Generated by Voice Recorder App with Real STT
        """.trimIndent()
        
        writeText(content)
        return transcription
    }
    
    fun File.writeTranscriptWithTranslation(
        audioData: List<Short>, 
        timestamp: String, 
        sampleRate: Int = 16000, 
        realTranscription: String = "", 
        translation: String = "",
        actualDurationMs: Long? = null
    ): String {
        // Use actual recording duration if provided, otherwise calculate from samples
        val duration = if (actualDurationMs != null) {
            actualDurationMs / 1000.0f
        } else {
            audioData.size / sampleRate.toFloat()
        }
        
        // Use real transcription if available, otherwise provide fallback
        val transcription = if (realTranscription.isNotBlank()) {
            realTranscription
        } else {
            "[No speech detected or recognition failed]"
        }
        
        val translationSection = if (translation.isNotBlank()) {
            """
            
            TRANSLATION:
            $translation
            """.trimIndent()
        } else {
            ""
        }
        
        val content = """
            === VOICE RECORDING TRANSCRIPT ===
            Timestamp: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}
            Audio File: voice_${timestamp}.wav
            Duration: ${"%.2f".format(duration)}s
            Sample Rate: ${sampleRate}Hz
            Samples: ${audioData.size}
            STT Engine: Vosk (Offline)
            Translation: ML Kit (Offline)
            ================================
            
            TRANSCRIPTION:
            $transcription$translationSection
            
            Generated by Voice Recorder App with Offline STT & Translation
        """.trimIndent()
        
        writeText(content)
        return transcription
    }
    
    // Helper extension functions for proper little-endian byte conversion
    private fun Int.toLittleEndianByteArray() = byteArrayOf(
        (this and 0xFF).toByte(),
        ((this shr 8) and 0xFF).toByte(),
        ((this shr 16) and 0xFF).toByte(),
        ((this shr 24) and 0xFF).toByte()
    )
    
    private fun Short.toLittleEndianByteArray() = byteArrayOf(
        (this.toInt() and 0xFF).toByte(),
        ((this.toInt() shr 8) and 0xFF).toByte()
    )
    
    private fun Int.toLittleEndianShortArray() = this.toShort().toLittleEndianByteArray()
    
    // Legacy functions for backward compatibility
    private fun Int.toByteArray() = toLittleEndianByteArray()
    private fun Short.toByteArray() = toLittleEndianByteArray()
    private fun Int.toShortArray() = toLittleEndianShortArray()
} 