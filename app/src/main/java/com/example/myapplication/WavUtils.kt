package com.example.myapplication

import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.*

object WavUtils {
    
    fun File.writeWav(audioData: List<Short>, sampleRate: Int = 16000) {
        FileOutputStream(this).use { fos ->
            val dataSize = audioData.size * 2
            val fileSize = dataSize + 36
            
            // WAV header
            fos.write("RIFF".toByteArray())
            fos.write(fileSize.toByteArray())
            fos.write("WAVE".toByteArray())
            fos.write("fmt ".toByteArray())
            fos.write(16.toByteArray()) // PCM header size
            fos.write(1.toShortArray()) // PCM format
            fos.write(1.toShortArray()) // Mono
            fos.write(sampleRate.toByteArray()) // Sample rate
            fos.write((sampleRate * 2).toByteArray()) // Byte rate
            fos.write(2.toShortArray()) // Block align
            fos.write(16.toShortArray()) // Bits per sample
            fos.write("data".toByteArray())
            fos.write(dataSize.toByteArray())
            
            // Audio data
            audioData.forEach { sample -> fos.write(sample.toByteArray()) }
        }
    }
    
    fun File.writeTranscript(audioData: List<Short>, timestamp: String, sampleRate: Int = 16000, realTranscription: String = ""): String {
        val duration = audioData.size / sampleRate.toFloat()
        
        // Use real transcription if available, otherwise provide fallback
        val transcription = if (realTranscription.isNotBlank()) {
            realTranscription
        } else {
            "[No speech detected or recognition failed]"
        }
        
        val content = """
            === VOICE RECORDING TRANSCRIPT ===
            Timestamp: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}
            Audio File: voice_${timestamp}.wav
            Duration: ${"%.2f".format(duration)}s
            Sample Rate: ${sampleRate}Hz
            Samples: ${audioData.size}
            STT Engine: Android SpeechRecognizer (On-device)
            ================================
            
            TRANSCRIPTION:
            $transcription
            
            Generated by Voice Recorder App with Real STT
        """.trimIndent()
        
        writeText(content)
        return transcription
    }
    
    fun File.writeTranscriptWithTranslation(audioData: List<Short>, timestamp: String, sampleRate: Int = 16000, realTranscription: String = "", translation: String = ""): String {
        val duration = audioData.size / sampleRate.toFloat()
        
        // Use real transcription if available, otherwise provide fallback
        val transcription = if (realTranscription.isNotBlank()) {
            realTranscription
        } else {
            "[No speech detected or recognition failed]"
        }
        
        val translationSection = if (translation.isNotBlank()) {
            """
            
            TRANSLATION:
            $translation
            """.trimIndent()
        } else {
            ""
        }
        
        val content = """
            === VOICE RECORDING TRANSCRIPT ===
            Timestamp: ${SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}
            Audio File: voice_${timestamp}.wav
            Duration: ${"%.2f".format(duration)}s
            Sample Rate: ${sampleRate}Hz
            Samples: ${audioData.size}
            STT Engine: Vosk (Offline)
            Translation: ML Kit (Offline)
            ================================
            
            TRANSCRIPTION:
            $transcription$translationSection
            
            Generated by Voice Recorder App with Offline STT & Translation
        """.trimIndent()
        
        writeText(content)
        return transcription
    }
    
    // Helper extension functions for byte conversion
    private fun Int.toByteArray() = byteArrayOf(
        (this and 0xFF).toByte(),
        ((this shr 8) and 0xFF).toByte(),
        ((this shr 16) and 0xFF).toByte(),
        ((this shr 24) and 0xFF).toByte()
    )
    
    private fun Short.toByteArray() = byteArrayOf(
        (this.toInt() and 0xFF).toByte(),
        ((this.toInt() shr 8) and 0xFF).toByte()
    )
    
    private fun Int.toShortArray() = this.toShort().toByteArray()
} 